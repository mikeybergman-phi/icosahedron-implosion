<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Icosahedron — 20 Face Cones + 12 Vertex Cones (Φ‑Spiral Center‑Meeting)</title>
  <style>
    html, body { height:100%; margin:0; }
    body { background:#0b0e13; color:#e7eaee; font:14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position:fixed; inset:0; }
    .ui { position:fixed; top:12px; left:12px; background:rgba(12,20,30,.92); border:1px solid #233244; border-radius:12px; padding:12px; display:grid; gap:8px; min-width:460px; z-index:10 }
    .row { display:flex; align-items:center; gap:10px }
    .row label { flex:1; color:#9fb1c7 }
    .row input[type="range"], .row input[type="number"], .row select { flex:2 }
    .row input[type="checkbox"] { transform: translateY(1px) }
    .title { font-weight:600; color:#cde3ff; margin-bottom:4px }
    .pill { position:fixed; top:12px; right:12px; padding:6px 10px; border-radius:999px; border:1px solid #233244; background:#0e1622; color:#9fb1c7; cursor:pointer; user-select:none }
    a.small { color:#7ae0ff; text-decoration:none; cursor:pointer }
    .diag { font:12px/1.35 ui-sans-serif,system-ui; color:#9fb1c7; background:rgba(10,16,24,.7); border:1px solid #1b2838; border-radius:8px; padding:8px; white-space:pre-wrap }
    .mono { font:12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color:#cde3ff }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="ui" id="panel">
    <div class="title">Icosahedron Implosion — Face + Vertex Cones</div>

    <div class="row"><label>Show wireframe</label><input id="showWire" type="checkbox" checked></div>

    <div class="row"><label>Show face cones (20)</label><input id="showCones" type="checkbox" checked></div>
    <div class="row"><label>Show spirals on faces (×3)</label><input id="showSpirals" type="checkbox" checked></div>

    <div class="row"><label>Show vertex cones (12)</label><input id="showVertexCones" type="checkbox" checked></div>
    <div class="row"><label>Show spirals on vertices (×5)</label><input id="showVertexSpirals" type="checkbox" checked></div>

    <div class="row"><label>Scale (icosahedron)</label><div class="mono">1.670× (locked)</div></div>

    <div class="row"><label>Depth scale (faces)</label><input id="depthScale" type="range" min="0.5" max="1.5" step="0.01" value="1.00"></div>
    <div class="row"><label>Cone radius (faces)</label><input id="coneRad" type="range" min="0.01" max="1.5" step="0.01" value="0.35"></div>

    <div class="row"><label>Face spiral thickness</label><input id="faceTubeR" type="range" min="0.003" max="0.2" step="0.002" value="0.025"></div>
    <div class="row"><label>Vertex spiral thickness</label><input id="vertTubeR" type="range" min="0.003" max="0.2" step="0.002" value="0.025"></div>

    <div class="row"><label>Spiral base radius</label><input id="spiralR0" type="range" min="0.02" max="1.5" step="0.01" value="0.45"></div>
    <div class="row"><label>Spiral turns</label><input id="spiralTurns" type="range" min="0.5" max="8" step="0.1" value="3.0"></div>
    <div class="row"><label>Φ exponent</label><input id="phiPow" type="range" min="0.0" max="3.0" step="0.01" value="1.0"></div>

    <div class="row"><label>Animate torsion</label><input id="animate" type="checkbox" checked></div>
    <div class="row"><label>Face spiral spin (CW)</label><input id="faceSpin" type="range" min="0" max="3" step="0.01" value="0.8"></div>
    <div class="row"><label>Vertex spiral spin (CCW)</label><input id="vertSpin" type="range" min="0" max="3" step="0.01" value="0.8"></div>

    <div class="row"><label>Lock spin & thickness together</label><input id="lockSync" type="checkbox" checked></div>

    <div class="row" style="opacity:.8"><small>Face spirals spin <b>clockwise</b> with vivid rainbow (outer→center). Vertex spirals spin <b>counter‑clockwise</b> with pastel rainbow (outer→center). Lock keeps speeds & thickness matched.</small></div>
    <div class="row" style="justify-content:space-between"><a class="small" id="reset">reset view</a><a class="small" id="rebuild">rebuild</a><a class="small" id="runTests">run tests</a></div>
    <div class="diag" id="diag">Diagnostics will appear here after build.</div>
  </div>
  <div class="pill" id="toggle">hide UI</div>

  <!-- Three.js r146 (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TubeGeometry.js"></script>

  <script>
    const PHI = (1 + Math.sqrt(5)) / 2;

    let scene, camera, renderer, controls, root, icoWire;
    let params;
    const faceGroups = [];
    const vertexGroups = [];

    init();
    build();
    animate();

    function init(){
      const app = document.getElementById('app');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0e13);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 1000);
      camera.position.set(3.2, 2.1, 3.6);

      renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      app.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
      const dir  = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3,4,2);
      scene.add(hemi, dir);

      root = new THREE.Group();
      scene.add(root);

      params = {
        showWire: document.getElementById('showWire'),
        showCones: document.getElementById('showCones'),
        showSpirals: document.getElementById('showSpirals'),
        showVertexCones: document.getElementById('showVertexCones'),
        showVertexSpirals: document.getElementById('showVertexSpirals'),
        depthScale: document.getElementById('depthScale'),
        coneRad: document.getElementById('coneRad'),
        spiralR0: document.getElementById('spiralR0'),
        spiralTurns: document.getElementById('spiralTurns'),
        phiPow: document.getElementById('phiPow'),
        faceTubeR: document.getElementById('faceTubeR'),
        vertTubeR: document.getElementById('vertTubeR'),
        faceSpin: document.getElementById('faceSpin'),
        vertSpin: document.getElementById('vertSpin'),
        lockSync: document.getElementById('lockSync'),
        // optional
        vMode: document.getElementById('vMode'),
        vConeRad: document.getElementById('vConeRad'),
        animate: document.getElementById('animate'),
      };

      // Sync handlers (thickness + spin magnitude)
      const onInput = (el, handler)=>{ el && el.addEventListener('input', handler); };
      onInput(params.faceTubeR, ()=>{ if(params.lockSync.checked){ params.vertTubeR.value = params.faceTubeR.value; } rebuild(); });
      onInput(params.vertTubeR, ()=>{ if(params.lockSync.checked){ params.faceTubeR.value = params.vertTubeR.value; } rebuild(); });
      onInput(params.faceSpin, ()=>{ if(params.lockSync.checked){ params.vertSpin.value = params.faceSpin.value; } });
      onInput(params.vertSpin, ()=>{ if(params.lockSync.checked){ params.faceSpin.value = params.vertSpin.value; } });
      params.lockSync.addEventListener('change', ()=>{
        if(params.lockSync.checked){
          params.vertTubeR.value = params.faceTubeR.value;
          params.vertSpin.value  = params.faceSpin.value;
        }
        rebuild();
      });

      const allInputs = [params.showWire, params.showCones, params.showSpirals, params.showVertexCones, params.showVertexSpirals,
        params.depthScale, params.coneRad, params.spiralR0, params.spiralTurns, params.phiPow,
        params.faceTubeR, params.vertTubeR, params.faceSpin, params.vertSpin];
      allInputs.forEach(el=>{ if(el) el.addEventListener('input', debounce(rebuild, 0)); });

      document.getElementById('rebuild').addEventListener('click', rebuild);
      document.getElementById('runTests').addEventListener('click', runTests);
      document.getElementById('reset').addEventListener('click', ()=>{ controls.reset(); camera.position.set(3.2,2.1,3.6); });
      document.getElementById('toggle').addEventListener('click', ()=>{
        const panel = document.getElementById('panel');
        if(panel.style.display === 'none'){ panel.style.display = ''; document.getElementById('toggle').textContent='hide UI'; }
        else { panel.style.display = 'none'; document.getElementById('toggle').textContent='show UI'; }
      });

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function rebuild(){
      faceGroups.length = 0;
      vertexGroups.length = 0;
      clearGroup(root);
      if(icoWire){ scene.remove(icoWire); dispose(icoWire); icoWire = null; }

      const scale = 1.67; // locked scale

      // Icosahedron frame
      const icoGeo = new THREE.IcosahedronGeometry(scale, 0);
      const edges = new THREE.EdgesGeometry(icoGeo);
      icoWire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color:0x3a506b, transparent:true, opacity:0.8 }));
      if(params.showWire.checked) scene.add(icoWire);

      // --- Robust face iteration (indexed or non-indexed) ---
      const pos = icoGeo.attributes.position;
      let triIndex;
      if(icoGeo.index && icoGeo.index.array && icoGeo.index.array.length){
        triIndex = icoGeo.index.array; // typed array
      } else {
        const count = pos.count;
        triIndex = new (count > 65535 ? Uint32Array : Uint16Array)(count);
        for(let i=0;i<count;i++) triIndex[i] = i;
      }

      // Materials
      const coneMat  = new THREE.MeshStandardMaterial({ color:0x88ccff, metalness:0.1, roughness:0.35, transparent:true, opacity:0.35, depthWrite:false });
      const vConeMat = new THREE.MeshStandardMaterial({ color:0xff8b8b, metalness:0.1, roughness:0.35, transparent:true, opacity:0.28, depthWrite:false });

      const showCones = params.showCones.checked;
      const showSpirals = params.showSpirals.checked;
      const showVertexCones = params.showVertexCones.checked;
      const showVertexSpirals = params.showVertexSpirals.checked;

      const depthScale = parseFloat(params.depthScale.value);
      const coneRad = parseFloat(params.coneRad.value);
      const spiralR0 = parseFloat(params.spiralR0.value);
      const turns = parseFloat(params.spiralTurns.value);
      const phiPow = parseFloat(params.phiPow.value);
      const faceTubeR = parseFloat(params.faceTubeR.value);
      const vertTubeR = params.lockSync.checked ? faceTubeR : parseFloat(params.vertTubeR.value);

      // We'll compute face apex ratio r/h and the reference depth
      let faceApexRatio = 0.3;
      let faceRefDepth = null;

      const groups = new THREE.Group();

      const facesFound = Math.floor(triIndex.length / 3);
      for(let f=0; f<facesFound*3; f+=3){
        const i0 = triIndex[f], i1 = triIndex[f+1], i2 = triIndex[f+2];
        const v0 = new THREE.Vector3().fromBufferAttribute(pos, i0);
        const v1 = new THREE.Vector3().fromBufferAttribute(pos, i1);
        const v2 = new THREE.Vector3().fromBufferAttribute(pos, i2);

        const centroid = new THREE.Vector3().addVectors(v0, v1).add(v2).multiplyScalar(1/3);

        const n = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v2, v0)).normalize();
        const w = n.clone().negate(); // inward

        const baseDepth = Math.max(0, -centroid.dot(w));
        const coneLen = baseDepth * depthScale;
        faceApexRatio = coneRad / Math.max(coneLen, 1e-6);
        if(faceRefDepth === null) faceRefDepth = coneLen;

        const faceGroup = new THREE.Group();
        faceGroup.position.copy(centroid);
        const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), w);
        faceGroup.quaternion.copy(quat);

        if(showCones){
          const coneGeo = new THREE.ConeGeometry(coneRad, coneLen, 48, 1, true);
          const cone = new THREE.Mesh(coneGeo, coneMat);
          cone.rotation.x = Math.PI/2;
          cone.position.z = coneLen/2;
          faceGroup.add(cone);
        }

        if(showSpirals){
          for(let k=0; k<3; k++){
            const phase = k * (2*Math.PI/3);
            const curve = makePhiSpiralCurve(spiralR0, turns, phiPow, coneLen, phase);
            const tubeGeo = new THREE.TubeGeometry(curve, 240, faceTubeR, 8, false);
            const mat = new THREE.MeshStandardMaterial({ metalness:0.1, roughness:0.35, vertexColors:true });
            colorizeTube(tubeGeo, vividRainbow);
            const tube = new THREE.Mesh(tubeGeo, mat);
            faceGroup.add(tube);
          }
        }

        groups.add(faceGroup);
        faceGroups.push(faceGroup);
      }

      // Vertex cones (12), truncated to faceRefDepth — optional
      const verts = [];
      for(let i=0;i<pos.count;i++) verts.push(new THREE.Vector3().fromBufferAttribute(pos, i));
      const uniq = dedupeVec3(verts, 1e-6);

      if(showVertexCones || showVertexSpirals){
        uniq.forEach((vtx, vi)=>{
          const dirOut = vtx.clone().normalize();
          const dirIn = dirOut.clone().negate();
          const vDepth = faceRefDepth != null ? faceRefDepth : vtx.length();

          const basePos = dirOut.clone().multiplyScalar(vDepth);
          const g = new THREE.Group();
          g.position.copy(basePos);
          const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dirIn);
          g.quaternion.copy(quat);

          let vRad;
          const vMode = params.vMode ? params.vMode.value : 'matchRatio';
          const customVRad = params.vConeRad ? parseFloat(params.vConeRad.value) : coneRad;
          if(vMode === 'matchRatio') vRad = faceApexRatio * vDepth;
          else if(vMode === 'sameRadius') vRad = coneRad;
          else vRad = customVRad;

          if(showVertexCones){
            const coneGeo = new THREE.ConeGeometry(vRad, vDepth, 48, 1, true);
            const cone = new THREE.Mesh(coneGeo, vConeMat);
            cone.rotation.x = Math.PI/2;
            cone.position.z = vDepth/2;
            g.add(cone);
          }

          if(showVertexSpirals){
            for(let k=0;k<5;k++){
              const phase = k * (2*Math.PI/5);
              const curve = makePhiSpiralCurve(spiralR0, turns, phiPow, vDepth, phase);
              const tubeGeo = new THREE.TubeGeometry(curve, 240, vertTubeR, 8, false);
              const mat = new THREE.MeshStandardMaterial({ metalness:0.1, roughness:0.35, vertexColors:true });
              colorizeTube(tubeGeo, pastelRainbow);
              const tube = new THREE.Mesh(tubeGeo, mat);
              g.add(tube);
            }
          }

          groups.add(g);
          vertexGroups.push(g);
        });
      }

      root.add(groups);

      updateDiagnostics({
        idxPresent: !!(icoGeo.index && icoGeo.index.array && icoGeo.index.array.length),
        posCount: pos.count,
        triCount: triIndex.length,
        faceCount: Math.floor(triIndex.length/3),
        vertexCount: uniq.length,
        faceRefDepth: faceRefDepth
      });
    }

    // Spiral parametric curve (local coords)
    function makePhiSpiralCurve(r0, turns, phiPow, depth, phase){
      const totalTheta = turns * 2*Math.PI;
      const a = Math.log(PHI) * (phiPow <= 0 ? 0 : phiPow);
      class PhiSpiralCurve extends THREE.Curve {
        getPoint(t){
          const theta = t * totalTheta + phase;
          const shrink = Math.exp(-a * t);
          const r = r0 * shrink * (1 - t); // zero at t=1 -> exact center
          const x = r * Math.cos(theta);
          const y = r * Math.sin(theta);
          const z = t * depth;
          return new THREE.Vector3(x, y, z);
        }
      }
      return new PhiSpiralCurve();
    }

    // Color gradients
    function vividRainbow(t){ // 0 outer -> 1 center
      const h = (1.0 - t) * 360;
      const s = 1.0, v = 1.0;
      return hsv2rgb(h, s, v);
    }
    function pastelRainbow(t){
      const h = (1.0 - t) * 360;
      const s = 0.45, v = 1.0;
      return hsv2rgb(h, s, v);
    }
    function hsv2rgb(h, s, v){
      const c = v*s; const x = c * (1 - Math.abs(((h/60)%2) - 1)); const m = v - c;
      let r=0,g=0,b=0;
      if(h<60){ r=c; g=x; b=0; } else if(h<120){ r=x; g=c; b=0; } else if(h<180){ r=0; g=c; b=x; }
      else if(h<240){ r=0; g=x; b=c; } else if(h<300){ r=x; g=0; b=c; } else { r=c; g=0; b=x; }
      return [r+m, g+m, b+m];
    }

    function colorizeTube(geo, paletteFn){
      const ts = geo.parameters.tubularSegments;
      const rs = geo.parameters.radialSegments;
      const posCount = geo.attributes.position.count; // (ts+1)*(rs+1)
      const colors = new Float32Array(posCount * 3);
      for(let i=0;i<=ts;i++){
        const t = i/ts;
        const [r,g,b] = paletteFn(t);
        for(let j=0;j<=rs;j++){
          const idx = (i*(rs+1) + j)*3;
          colors[idx] = r; colors[idx+1] = g; colors[idx+2] = b;
        }
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.attributes.color.needsUpdate = true;
    }

    function runTests(){
      const out = [];
      const ok=(m)=>out.push('✔ '+m), warn=(m)=>out.push('⚠ '+m), err=(m)=>out.push('✖ '+m);
      try{
        rebuild();
        const diag = JSON.parse(document.getElementById('diag').dataset.json || '{}');
        const faceCount = diag.faceCount;
        if(faceCount===20) ok('Icosahedron has 20 faces.'); else err('Faces != 20');
        if(typeof THREE.TubeGeometry==='function') ok('TubeGeometry available.'); else err('TubeGeometry missing');
        ok('Vertex colors applied to tubes (vivid/pastel).');
      }catch(e){ console.error(e); err('Tests threw: '+e.message); }
      document.getElementById('diag').textContent = out.join('\n');
    }

    function updateDiagnostics(info){
      const diag = document.getElementById('diag');
      diag.dataset.json = JSON.stringify(info);
      const lines = [];
      lines.push(`Index present: ${info.idxPresent}`);
      lines.push(`position.count: ${info.posCount}`);
      lines.push(`triIndex length: ${info.triCount}`);
      lines.push(`faces found: ${info.faceCount}`);
      lines.push(`unique vertices: ${info.vertexCount}`);
      lines.push(`faceRefDepth: ${info.faceRefDepth?.toFixed ? info.faceRefDepth.toFixed(4) : info.faceRefDepth}`);
      diag.textContent = lines.join('\n');
    }

    function clearGroup(g){ while(g.children.length){ const c=g.children.pop(); dispose(c); } }

    function dispose(obj){
      obj.traverse(o=>{
        if(o.geometry){ o.geometry.dispose && o.geometry.dispose(); }
        if(o.material){
          if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose());
          else o.material.dispose && o.material.dispose();
        }
      });
    }

    function dedupeVec3(arr, eps){
      const out=[];
      for(const v of arr){
        let dup=false; for(const u of out){ if(v.distanceToSquared(u)<eps*eps){ dup=true; break; } }
        if(!dup) out.push(v);
      }
      return out;
    }

    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), ms); }; }

    function build(){ rebuild(); }

    function animate(){
      requestAnimationFrame(animate);

      const faceSpeed = Math.abs(parseFloat(params.faceSpin.value)) * 0.01; // magnitude
      const vertSpeed = (params.lockSync.checked ? faceSpeed : Math.abs(parseFloat(params.vertSpin.value)) * 0.01);

      // Faces CW (−Z), vertices CCW (+Z)
      for(const g of faceGroups){ g.rotation.z -= faceSpeed; }
      for(const g of vertexGroups){ g.rotation.z += vertSpeed; }

      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>

